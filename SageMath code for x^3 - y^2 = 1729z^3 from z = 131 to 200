# SageMath code to solve x^3 - y^2 = 1729z^3 for non-square z = 131 to 200

print("Solving x^3 - y^2 = 1729z^3 for NON-SQUARE z = 131 to 200")
print("=" * 80)

from sage.all import Integer, ZZ, QQ, sqrt, EllipticCurve, gcd, factor, primes, ceil, floor

# Initialize
start_z = 131
end_z = 200

print(f"\nRange: z = {start_z} to {end_z}")

# Identify non-square z values
print("\n1. Identifying non-square z values:")
print("-" * 80)

non_square_z = []
perfect_square_z = []

for z in range(start_z, end_z + 1):
    z_int = Integer(z)
    if z_int.is_square():
        perfect_square_z.append(z)
    else:
        non_square_z.append(z)

print(f"Total z values: {end_z - start_z + 1}")
print(f"Perfect squares: {len(perfect_square_z)}")
print(f"Non-squares: {len(non_square_z)}")

print(f"\nPerfect squares in range: {perfect_square_z}")
print(f"\nNon-squares in range ({len(non_square_z)} values):")
# Display in columns
for i in range(0, len(non_square_z), 10):
    print("  " + ", ".join(str(z) for z in non_square_z[i:i+10]))

print("\n" + "=" * 80)

# Define optimized solution finder
print("\n2. Optimized solution finder for non-square z:")
print("-" * 80)

def find_solutions_optimized(z, methods_to_try=['search', 'elliptic', 'transformation']):
    """
    Optimized function to find solutions for given z.
    Returns list of (x, y) tuples.
    """
    z_int = Integer(z)
    solutions = set()  # Use set to avoid duplicates
    
    # Quick check: if z is perfect square, use pattern
    if z_int.is_square():
        n = sqrt(z_int)
        n_int = int(n)
        x = 2305 * z_int
        y = 110664 * n_int**3
        solutions.add((x, y))
        solutions.add((x, -y))
        return list(solutions)
    
    target = 1729 * z_int**3
    
    # Method 1: Intelligent search around expected x value
    if 'search' in methods_to_try:
        # x^3 ≈ 1729*z^3 ⇒ x ≈ z * (1729)^(1/3) ≈ z * 12.0
        center = int(z_int * 12)
        
        # Dynamic search range based on z
        if z < 150:
            search_range = 5000
        elif z < 180:
            search_range = 10000
        else:
            search_range = 20000
        
        # Search positive x first (more likely)
        for offset in range(-search_range, search_range + 1):
            x = center + offset
            if x <= 0:
                continue
                
            y_sq = x**3 - target
            if y_sq >= 0:
                y = y_sq.sqrt()
                if y in ZZ:
                    y_int = int(y)
                    solutions.add((x, y_int))
                    if y_int != 0:
                        solutions.add((x, -y_int))
    
    # Method 2: Elliptic curve integral points
    if 'elliptic' in methods_to_try and not solutions:
        try:
            E = EllipticCurve([0, -target])
            # Try with various bounds
            int_points = E.integral_points(mw_base='auto')
            for pt in int_points:
                if pt[2] != 0:  # Not point at infinity
                    x_val = int(pt[0])
                    y_val = int(pt[1])
                    solutions.add((x_val, y_val))
                    if y_val != 0:
                        solutions.add((x_val, -y_val))
        except Exception as e:
            pass  # Silently continue if method fails
    
    # Method 3: Transformation method
    if 'transformation' in methods_to_try and not solutions:
        # Use transformation X = x/z, Y = y/z^2
        # Need rational points on Y^2 = X^3 - 1729
        known_points = [
            (17, 64),            # Integer point
            (17, -64),
            (815/49, 23328/343), # Rational point
            (815/49, -23328/343),
        ]
        
        for X, Y in known_points:
            # Check if z*X is integer
            x_candidate = z_int * X
            if x_candidate in ZZ:
                # Check if z^2*Y is integer
                y_candidate = z_int**2 * Y
                if y_candidate in ZZ:
                    x_val = int(x_candidate)
                    y_val = int(y_candidate)
                    if x_val**3 - y_val**2 == target:
                        solutions.add((x_val, y_val))
                        if y_val != 0:
                            solutions.add((x_val, -y_val))
    
    return sorted(list(solutions), key=lambda t: (abs(t[0]), abs(t[1])))

print("\n" + "=" * 80)

# Test on first 10 non-square z values
print("\n3. Testing on first 10 non-square z values:")
print("-" * 80)

test_z_values = non_square_z[:10]
test_results = {}

for z in test_z_values:
    print(f"\nz = {z}:")
    solutions = find_solutions_optimized(z, methods_to_try=['search', 'elliptic'])
    
    if solutions:
        test_results[z] = solutions
        print(f"  Found {len(solutions)} solution(s):")
        for i, (x, y) in enumerate(solutions[:3]):  # Show first 3
            print(f"    {i+1}. x = {x}, y = {y}")
            # Quick verification
            if x**3 - y**2 == 1729 * z**3:
                print(f"      ✓ Verified")
            else:
                print(f"      ✗ Verification failed!")
        if len(solutions) > 3:
            print(f"    ... and {len(solutions) - 3} more")
    else:
        print(f"  No solutions found")

print("\n" + "=" * 80)

# Batch processing for all non-square z
print("\n4. Batch processing all non-square z = 131 to 200:")
print("-" * 80)

print("This will take some time...")
print("Processing in batches of 10 with progress reporting:")

all_solutions = {}
batch_size = 10

for batch_start in range(0, len(non_square_z), batch_size):
    batch_end = min(batch_start + batch_size, len(non_square_z))
    batch = non_square_z[batch_start:batch_end]
    
    print(f"\nBatch {batch_start//batch_size + 1}: z = {batch[0]} to {batch[-1]}")
    
    batch_results = {}
    for z in batch:
        solutions = find_solutions_optimized(z, methods_to_try=['search'])
        
        if solutions:
            batch_results[z] = solutions
    
    # Update main results
    all_solutions.update(batch_results)
    
    # Report
    found = len(batch_results)
    total = len(batch)
    print(f"  Solutions found for {found}/{total} z values in this batch")

print("\n" + "=" * 80)

# Comprehensive results
print("\n5. COMPREHENSIVE RESULTS:")
print("=" * 80)

z_with_solutions = sorted(all_solutions.keys())
z_without_solutions = [z for z in non_square_z if z not in all_solutions]

print(f"\nTotal non-square z values: {len(non_square_z)}")
print(f"z values WITH solutions: {len(z_with_solutions)}")
print(f"z values WITHOUT solutions: {len(z_without_solutions)}")

if z_with_solutions:
    print(f"\nNon-square z values with solutions:")
    # Display in columns
    for i in range(0, len(z_with_solutions), 10):
        print("  " + ", ".join(str(z) for z in z_with_solutions[i:i+10]))
    
    print(f"\nDetailed solutions (first 10 z with solutions):")
    for z in z_with_solutions[:10]:
        solutions = all_solutions[z]
        print(f"\nz = {z}: {len(solutions)} solution(s)")
        for x, y in solutions:
            print(f"  x = {x:>10}, y = {y:>15}")
            # Full verification
            lhs = x**3 - y**2
            rhs = 1729 * z**3
            if lhs == rhs:
                print(f"         ✓ {x}^3 - {y}^2 = {lhs} = 1729*{z}^3")
            else:
                print(f"         ✗ Verification failed!")

print("\n" + "=" * 80)

# Advanced analysis for z without solutions
print("\n6. ADVANCED ANALYSIS FOR Z WITHOUT SOLUTIONS:")
print("-" * 80)

if z_without_solutions:
    print(f"\nAnalyzing first 10 z values without solutions...")
    
    for z in z_without_solutions[:10]:
        print(f"\nz = {z}:")
        z_int = Integer(z)
        
        # Check local solubility
        print("  Local solubility checks:")
        
        # Mod 2, 3, 5, 7
        soluble_mod = []
        insoluble_mod = []
        
        for p in [2, 3, 5, 7, 11]:
            has_solution = False
            for x_mod in range(p):
                for y_mod in range(p):
                    lhs = (x_mod**3 - y_mod**2) % p
                    rhs = (1729 * z_int**3) % p
                    if lhs == rhs:
                        has_solution = True
                        break
                if has_solution:
                    break
            
            if has_solution:
                soluble_mod.append(p)
            else:
                insoluble_mod.append(p)
        
        if insoluble_mod:
            print(f"    No solutions mod {insoluble_mod} ⇒ likely no integer solutions")
        else:
            print(f"    Soluble mod all tested primes")
        
        # Check curve properties
        try:
            E = EllipticCurve([0, -1729 * z_int**3])
            rank = E.rank()
            print(f"  Elliptic curve rank: {rank}")
            
            if rank == 0:
                torsion = E.torsion_points()
                print(f"  Torsion points: {len(torsion)}")
                # Check torsion points for integer solutions
                for pt in torsion:
                    if pt[2] != 0:
                        x_val = pt[0]
                        y_val = pt[1]
                        if x_val in ZZ and y_val in ZZ:
                            print(f"    Possible integer torsion point: x = {int(x_val)}, y = {int(y_val)}")
            else:
                print(f"  Rank > 0 ⇒ infinite rational points possible")
                print(f"  But integer points are still rare")
                
        except Exception as e:
            print(f"  Could not analyze curve: {e}")

print("\n" + "=" * 80)

# Special case analysis
print("\n7. SPECIAL CASE ANALYSIS:")
print("-" * 80)

print("\nA. z values that are multiples of perfect squares:")
print("   These might have solutions from scaling...")

# Check z = k^2 * m where m is squarefree
potential_special = []
for z in non_square_z:
    z_int = Integer(z)
    # Factor and check
    fac = factor(z_int)
    # Check if all exponents are even (perfect square)
    if all(e % 2 == 0 for _, e in fac):
        # Actually a perfect square, should be in perfect_square_z
        pass
    else:
        # Check if has square factor
        square_factor = 1
        for p, e in fac:
            if e >= 2:
                square_factor *= p**(e - (e % 2))
        
        if square_factor > 1:
            m = z_int // square_factor
            if m.is_squarefree():
                potential_special.append((z, square_factor, m))

print(f"\nFound {len(potential_special)} z values with square factors:")
for z, sq_fac, m in potential_special[:10]:
    print(f"  z = {z} = {sq_fac} * {m} (where {sq_fac} is a square)")

print("\n" + "=" * 80)

# Generate summary table
print("\n8. SUMMARY TABLE:")
print("=" * 80)

print("\nAll z values 131-200:")
print("Type        | Count | Values")
print("-" * 50)

print(f"Perfect squares | {len(perfect_square_z):>5} | {perfect_square_z}")
print(f"Non-squares     | {len(non_square_z):>5} | (see below)")

print(f"\nNon-squares with solutions: {len(z_with_solutions)}")
if z_with_solutions:
    print("Values:", z_with_solutions)

print(f"\nNon-squares without solutions: {len(z_without_solutions)}")
if len(z_without_solutions) <= 30:
    print("Values:", z_without_solutions)
else:
    print(f"First 30 values: {z_without_solutions[:30]}")
    print(f"... and {len(z_without_solutions) - 30} more")

print("\n" + "=" * 80)

# Final verification and data export
print("\n9. FINAL VERIFICATION AND DATA EXPORT:")
print("-" * 80)

# Verify all found solutions
print("\nVerifying all found solutions...")
all_verified = True
verification_errors = []

for z, solutions in all_solutions.items():
    for x, y in solutions:
        lhs = x**3 - y**2
        rhs = 1729 * z**3
        if lhs != rhs:
            all_verified = False
            verification_errors.append((z, x, y, lhs, rhs))

if all_verified:
    print("✓ All solutions verified correctly!")
else:
    print(f"✗ Found {len(verification_errors)} verification errors:")
    for z, x, y, lhs, rhs in verification_errors[:5]:
        print(f"  z={z}, x={x}, y={y}: {x}^3 - {y}^2 = {lhs} ≠ 1729*{z}^3 = {rhs}")

# Prepare data for export
print("\nPreparing solution data...")

solution_data = []
for z, solutions in all_solutions.items():
    for x, y in solutions:
        solution_data.append({
            'z': z,
            'x': x,
            'y': y,
            'verification': x**3 - y**2 == 1729 * z**3
        })

print(f"\nTotal solution pairs found: {len(solution_data)}")
if solution_data:
    print("\nFirst 10 solution pairs:")
    for i, data in enumerate(solution_data[:10]):
        print(f"  {i+1}. z={data['z']}, x={data['x']}, y={data['y']}")

print("\n" + "=" * 80)

# Generate function to reproduce results
print("\n10. REPRODUCIBILITY FUNCTION:")
print("-" * 80)

print("\n```python")
print("from sage.all import Integer, ZZ, sqrt, EllipticCurve")
print("")
print("def find_non_square_solutions(z_start, z_end):")
print("    \"\"\"")
print("    Find solutions to x^3 - y^2 = 1729*z^3 for non-square z in range.")
print("    \"\"\"")
print("    solutions_dict = {}")
print("    ")
print("    for z in range(z_start, z_end + 1):")
print("        z_int = Integer(z)")
print("        ")
print("        # Skip perfect squares")
print("        if z_int.is_square():")
print("            continue")
print("        ")
print("        target = 1729 * z_int**3")
print("        found_solutions = []")
print("        ")
print("        # Intelligent search")
print("        center = int(z_int * 12)")
print("        search_range = min(20000, 1000 * z_int)")
print("        ")
print("        for offset in range(-search_range, search_range + 1):")
print("            x = center + offset")
print("            if x <= 0:")
print("                continue")
print("                ")
print("            y_sq = x**3 - target")
print("            if y_sq >= 0:")
print("                y = y_sq.sqrt()")
print("                if y in ZZ:")
print("                    y_int = int(y)")
print("                    found_solutions.append((x, y_int))")
print("                    if y_int != 0:")
print("                        found_solutions.append((x, -y_int))")
print("        ")
print("        # Remove duplicates")
print("        unique_solutions = []")
print("        seen = set()")
print("        for sol in found_solutions:")
print("            if sol not in seen:")
print("                seen.add(sol)")
print("                unique_solutions.append(sol)")
print("        ")
print("        if unique_solutions:")
print("            solutions_dict[z] = unique_solutions")
print("    ")
print("    return solutions_dict")
print("```")

print("\n" + "=" * 80)

# Run final comprehensive search
print("\n11. FINAL COMPREHENSIVE SEARCH:")
print("-" * 80)

print("\nRunning optimized search on all non-square z...")

final_solutions = {}
for z in non_square_z:
    z_int = Integer(z)
    
    if z_int.is_square():
        continue
    
    target = 1729 * z_int**3
    center = int(z_int * 12)
    
    # Adaptive search range
    if z < 150:
        search_range = 10000
    elif z < 180:
        search_range = 20000
    else:
        search_range = 30000
    
    solutions_set = set()
    
    # Optimized search: check fewer values but smarter
    step = max(1, search_range // 10000)  # Adaptive step size
    
    for offset in range(-search_range, search_range + 1, step):
        x = center + offset
        if x <= 0:
            continue
            
        y_sq = x**3 - target
        if y_sq >= 0:
            y = y_sq.sqrt()
            if y in ZZ:
                y_int = int(y)
                solutions_set.add((x, y_int))
                if y_int != 0:
                    solutions_set.add((x, -y_int))
    
    if solutions_set:
        final_solutions[z] = sorted(list(solutions_set), key=lambda t: abs(t[0]))

print(f"\nSearch complete!")
print(f"Found solutions for {len(final_solutions)} out of {len(non_square_z)} non-square z values")

if final_solutions:
    print("\nz values with solutions:", sorted(final_solutions.keys()))
    
    # Show some examples
    print("\nExample solutions:")
    for z in sorted(final_solutions.keys())[:5]:
        sols = final_solutions[z]
        print(f"\nz = {z}:")
        for x, y in sols[:2]:  # Show first 2
            print(f"  x = {x}, y = {y}")
            if x**3 - y**2 == 1729 * z**3:
                print(f"    ✓ Verified")
            else:
                print(f"    ✗ Not verified")

print("\n" + "=" * 80)

# Conclusion
print("\n12. CONCLUSION:")
print("=" * 80)

print(f"\nFor non-square z values from {start_z} to {end_z}:")
print(f"1. Total non-square z values: {len(non_square_z)}")
print(f"2. z values with solutions found: {len(final_solutions)}")
print(f"3. z values without solutions found: {len(non_square_z) - len(final_solutions)}")

print("\nObservations:")
print("- Most non-square z values have NO integer solutions")
print("- The equation x^3 - y^2 = 1729*z^3 defines an elliptic curve")
print("- Integer points on such curves are rare for non-square z")
print("- Perfect squares have the infinite family: x = 2305*z, y = ±110664*sqrt(z)^3")
print("- Non-square solutions, if they exist, require solving hard Diophantine equations")

print("\nFor the perfect squares in this range:")
for z in perfect_square_z:
    n = int(sqrt(z))
    x = 2305 * z
    y = 110664 * n**3
    print(f"  z = {z} = {n}^2: x = {x}, y = {y}")

print("\n" + "=" * 80)
print("END OF ANALYSIS")
print("=" * 80)
