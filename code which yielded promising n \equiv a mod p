from sage.all import *
import time

def find_solutions_CRT(limit_n=10**8, search_range=10**5):
    """
    Use Chinese Remainder Theorem to construct n that satisfies
    all modular constraints, then search for x,y.
    """
    print("="*60)
    print("CRT-based search for solutions")
    print("="*60)
    
    # First 20 prime constraints (more accurate for larger n)
    constraints = [
        (5, [4]),
        (11, [10]),
        (17, [1]),
        (19, [0]),
        (23, [19]),
        (29, [15]),
        (41, [22]),
        (47, [23]),
        (53, [18]),
        (59, [15]),
        (61, [16, 20, 25]),
        (71, [15]),
        (83, [76]),
        (89, [29]),
        (101, [97]),
        (107, [13]),
        (113, [19]),
        (131, [50]),
        (137, [122]),
        (149, [142])
    ]
    
    # Build all combinations of residues
    moduli = []
    all_residues = []
    
    for p, residues in constraints:
        moduli.append(p)
        all_residues.append(residues)
    
    # Generate CRT combinations
    solutions = []
    
    # Function to generate all CRT combinations recursively
    def generate_crt_combinations(index, current_mod, current_residue):
        if index == len(moduli):
            return [(current_mod, current_residue)]
        
        p = moduli[index]
        results = []
        for r in all_residues[index]:
            try:
                new_residue = crt([current_residue, r], [current_mod, p])
                new_mod = current_mod * p
                results.extend(generate_crt_combinations(index + 1, new_mod, new_residue))
            except:
                continue
        return results
    
    print("Generating CRT combinations...")
    crt_combinations = generate_crt_combinations(0, 1, 0)
    print(f"Found {len(crt_combinations)} CRT combinations")
    
    if not crt_combinations:
        print("No valid CRT combinations found!")
        return []
    
    # Search around each CRT solution
    for mod_val, base_n in crt_combinations[:10]:  # Limit to first 10 for demo
        print(f"\nSearching around n ≡ {base_n} (mod {mod_val})")
        
        # Start from base_n
        start_n = base_n
        if start_n == 0:
            start_n = mod_val
        
        # Search in range
        for k in range(search_range):
            n = start_n + k * mod_val
            if n > limit_n:
                break
            
            # Quick modular check with more primes
            if n % 5 != 4: continue
            if n % 11 != 10: continue
            if n % 17 != 1: continue
            if n % 19 != 0: continue
            
            C = 36*n**3 - 19
            
            # x must divide C
            # Search divisors efficiently
            divs = C.divisors()
            
            for x in divs:
                # Try positive x
                if x > 10**6:  # Limit x size
                    continue
                
                # Check if inside sqrt is perfect square
                inside = (x + 6*n)**2 + C // x
                if inside >= 0 and is_square(inside):
                    k_sqrt = sqrt(inside)
                    y = -x + k_sqrt
                    if y in ZZ:
                        solutions.append((n, x, y))
                        print(f"  Found: n={n}, x={x}, y={y}")
                
                # Try negative x
                x_neg = -x
                inside = (x_neg + 6*n)**2 + C // x_neg
                if inside >= 0 and is_square(inside):
                    k_sqrt = sqrt(inside)
                    y = -x_neg + k_sqrt
                    if y in ZZ:
                        solutions.append((n, x_neg, y))
                        print(f"  Found: n={n}, x={x_neg}, y={y}")
            
            if k % 1000 == 0 and k > 0:
                print(f"  Progress: k={k}, n={n}")
    
    return solutions


def transform_equation():
    """
    Transform the equation to find structure.
    Original: y = -x + sqrt((x+6n)^2 + (36n^3 - 19)/x)
    
    Square both sides after moving x:
    (y + x)^2 = (x+6n)^2 + (36n^3 - 19)/x
    
    Multiply by x:
    x(y + x)^2 = x(x+6n)^2 + (36n^3 - 19)
    
    This is a quartic in x when n is fixed.
    """
    print("\n" + "="*60)
    print("Equation transformation analysis")
    print("="*60)
    
    # The equation can be rewritten as:
    # x(y^2 + 2xy + x^2) = x(x^2 + 12nx + 36n^2) + 36n^3 - 19
    # xy^2 + 2x^2y + x^3 = x^3 + 12nx^2 + 36n^2x + 36n^3 - 19
    # xy^2 + 2x^2y = 12nx^2 + 36n^2x + 36n^3 - 19
    
    # Rearranging:
    # xy^2 + 2x^2y - 12nx^2 - 36n^2x - 36n^3 + 19 = 0
    # x(y^2 - 36n^2) + 2x^2(y - 6n) - 36n^3 + 19 = 0
    
    # This suggests x might be related to divisors of (36n^3 - 19)
    
    return None


def search_specific_n_values():
    """
    Search specific n values that satisfy many modular constraints.
    """
    print("\n" + "="*60)
    print("Searching specific promising n values")
    print("="*60)
    
    # From the constraints, let's find n that satisfy the first several
    # Use Chinese Remainder Theorem systematically
    
    # Important constraints (taking first residue where multiple exist)
    important_constraints = [
        (5, 4),
        (11, 10),
        (17, 1),
        (19, 0),
        (23, 19),
        (29, 15),
        (41, 22),
        (47, 23),
        (53, 18),
        (59, 15),
        (71, 15),
        (83, 76),
        (89, 29),
        (101, 97)
    ]
    
    # Try to find n satisfying all these
    moduli = [p for p, _ in important_constraints]
    residues = [r for _, r in important_constraints]
    
    try:
        n_crt = crt(residues, moduli)
        mod_product = prod(moduli)
        print(f"Found n ≡ {n_crt} (mod {mod_product})")
        print(f"Mod product = {mod_product:,}")
        
        solutions = []
        
        # Search a range of multiples
        num_multiples = 100
        print(f"\nSearching {num_multiples} multiples...")
        
        for k in range(num_multiples):
            n = n_crt + k * mod_product
            if n == 0:
                continue
            
            C = 36*n**3 - 19
            print(f"\nn = {n:,}")
            print(f"C = 36n³ - 19 = {C:,}")
            
            # Check if C has reasonable number of divisors
            num_divisors = len(C.divisors())
            print(f"Number of divisors: {num_divisors}")
            
            if num_divisors > 10000:
                print("  Too many divisors, skipping detailed check")
                continue
            
            # Check small x values first
            found_solution = False
            for x in range(1, min(1000, abs(C) // 1000 + 100)):
                if C % x == 0:
                    # Positive x
                    inside = (x + 6*n)**2 + C // x
                    if is_square(inside):
                        k_sqrt = sqrt(inside)
                        y = -x + k_sqrt
                        if y in ZZ:
                            solutions.append((n, x, y))
                            print(f"  Found: x={x}, y={y}")
                            found_solution = True
                    
                    # Negative x
                    x_neg = -x
                    inside = (x_neg + 6*n)**2 + C // x_neg
                    if is_square(inside):
                        k_sqrt = sqrt(inside)
                        y = -x_neg + k_sqrt
                        if y in ZZ:
                            solutions.append((n, x_neg, y))
                            print(f"  Found: x={x_neg}, y={y}")
                            found_solution = True
            
            if not found_solution:
                # Check a few specific divisors
                divs = C.divisors()
                # Check small divisors
                for x in divs[:50]:
                    if x > 10**6:
                        break
                    
                    inside = (x + 6*n)**2 + C // x
                    if is_square(inside):
                        k_sqrt = sqrt(inside)
                        y = -x + k_sqrt
                        if y in ZZ:
                            solutions.append((n, x, y))
                            print(f"  Found via divisor: x={x}, y={y}")
                
                # Check divisors near sqrt(C)
                sqrtC = C.sqrt().round()
                start_idx = max(0, len(divs)//2 - 25)
                end_idx = min(len(divs), len(divs)//2 + 25)
                
                for i in range(start_idx, end_idx):
                    x = divs[i]
                    inside = (x + 6*n)**2 + C // x
                    if is_square(inside):
                        k_sqrt = sqrt(inside)
                        y = -x + k_sqrt
                        if y in ZZ:
                            solutions.append((n, x, y))
                            print(f"  Found via mid divisor: x={x}, y={y}")
        
        return solutions
        
    except Exception as e:
        print(f"CRT failed: {e}")
        return []


def search_with_diophantine_approach():
    """
    Approach the problem as a Diophantine equation.
    Starting from: (y + x)^2 = (x + 6n)^2 + (36n^3 - 19)/x
    
    Let A = y + x and B = x + 6n
    Then: A^2 = B^2 + (36n^3 - 19)/x
    
    So: (A - B)(A + B) = (36n^3 - 19)/x
    """
    print("\n" + "="*60)
    print("Diophantine approach")
    print("="*60)
    
    # Let d = A - B = (y + x) - (x + 6n) = y - 6n
    # Then A + B = 2x + y + 6n
    # And d * (2x + y + 6n) = (36n^3 - 19)/x
    
    # So: x * d * (2x + y + 6n) = 36n^3 - 19
    
    # Since d = y - 6n, we have y = d + 6n
    # Substitute: x * d * (2x + (d + 6n) + 6n) = 36n^3 - 19
    # x * d * (2x + d + 12n) = 36n^3 - 19
    
    # This is a quadratic in x: 2d x^2 + d(d + 12n) x - (36n^3 - 19) = 0
    
    # The discriminant must be perfect square:
    # Δ = d^2(d + 12n)^2 + 8d(36n^3 - 19)
    
    solutions = []
    
    # Search for small d values
    print("Searching for small d values...")
    
    for n in range(1, 1000):
        # Apply modular filters first
        if n % 5 != 4: continue
        if n % 11 != 10: continue
        if n % 17 != 1: continue
        
        C = 36*n**3 - 19
        
        # d must divide C (from x*d*(2x+d+12n) = C)
        # Try divisors of C as potential d values
        for d in C.divisors():
            if abs(d) > 10000:  # Limit d size
                continue
            
            # Solve quadratic: 2d x^2 + d(d+12n) x - C = 0
            # Discriminant: D = d^2(d+12n)^2 + 8d*C
            
            D = d**2 * (d + 12*n)**2 + 8*d*C
            
            if D >= 0 and is_square(D):
                sqrtD = sqrt(D)
                
                # Check both solutions for x
                for sign in [1, -1]:
                    denom = 4*d
                    if denom == 0:
                        continue
                    
                    x_num = -d*(d + 12*n) + sign * sqrtD
                    if x_num % denom == 0:
                        x = x_num // denom
                        if x != 0:
                            # Check original equation
                            inside = (x + 6*n)**2 + C // x
                            if is_square(inside):
                                k_sqrt = sqrt(inside)
                                y = -x + k_sqrt
                                if y in ZZ:
                                    solutions.append((n, x, y))
                                    print(f"Found: n={n}, d={d}, x={x}, y={y}")
    
    return solutions


def brute_force_targeted():
    """
    Targeted brute force with smart constraints.
    """
    print("\n" + "="*60)
    print("Targeted brute force search")
    print("="*60)
    
    solutions = []
    
    # Generate n values that satisfy the first 8 constraints
    # This should give us promising candidates
    
    constraints = [
        (5, [4]),
        (11, [10]),
        (17, [1]),
        (19, [0]),
        (23, [19]),
        (29, [15]),
        (41, [22]),
        (47, [23])
    ]
    
    # Use CRT to find base solution
    moduli = [p for p, _ in constraints]
    residues_list = [r for _, r in constraints]
    
    # Take first residue for each
    residues = [r[0] for r in residues_list]
    
    try:
        n_base = crt(residues, moduli)
        mod_product = prod(moduli)
        
        print(f"Base n = {n_base} mod {mod_product}")
        print(f"Searching multiples...")
        
        # Search multiples
        for k in range(100):
            n = n_base + k * mod_product
            if n <= 0:
                continue
            
            C = 36*n**3 - 19
            
            # Try x values that are likely to work
            # x should be a divisor of C
            
            # Get divisors
            divs = C.divisors()
            
            # Check small divisors first (more likely)
            for x in divs[:min(100, len(divs))]:
                if x > 10**6:
                    break
                
                # Positive x
                inside = (x + 6*n)**2 + C // x
                if is_square(inside):
                    k_sqrt = sqrt(inside)
                    y = -x + k_sqrt
                    if y in ZZ:
                        solutions.append((n, x, y))
                        print(f"Solution: n={n}, x={x}, y={y}")
                
                # Negative x
                x_neg = -x
                inside = (x_neg + 6*n)**2 + C // x_neg
                if is_square(inside):
                    k_sqrt = sqrt(inside)
                    y = -x_neg + k_sqrt
                    if y in ZZ:
                        solutions.append((n, x_neg, y))
                        print(f"Solution: n={n}, x={x_neg}, y={y}")
            
            if k % 10 == 0:
                print(f"  Checked k={k}, n={n}")
    
    except Exception as e:
        print(f"Error: {e}")
    
    return solutions


# Main execution
if __name__ == "__main__":
    print("Searching for integer solutions to:")
    print("y = -x + √[(x+6n)² + (36n³ - 19)/x]")
    print("\nUsing modular constraints from analysis:")
    print("n ≡ 4 (mod 5), n ≡ 10 (mod 11), n ≡ 1 (mod 17), etc.")
    
    # Try different approaches
    approaches = [
        ("CRT-based search", find_solutions_CRT),
        ("Specific n values", search_specific_n_values),
        ("Diophantine approach", search_with_diophantine_approach),
        ("Targeted brute force", brute_force_targeted)
    ]
    
    all_solutions = []
    
    for name, func in approaches:
        print(f"\n{'='*60}")
        print(f"Running: {name}")
        print(f"{'='*60}")
        
        start_time = time.time()
        solutions = func()
        elapsed = time.time() - start_time
        
        if solutions:
            print(f"\nFound {len(solutions)} solutions in {elapsed:.2f} seconds:")
            for n, x, y in solutions[:10]:  # Show first 10
                print(f"  n={n}, x={x}, y={y}")
                # Verify
                lhs = y
                rhs = -x + sqrt((x + 6*n)**2 + (36*n**3 - 19)/x)
                print(f"  Verify: {lhs} == {rhs} ({lhs == rhs})")
            all_solutions.extend(solutions)
        else:
            print(f"No solutions found in {elapsed:.2f} seconds")
    
    # Final summary
    print(f"\n{'='*60}")
    print("FINAL SUMMARY")
    print(f"{'='*60}")
    
    if all_solutions:
        unique_solutions = sorted(set(all_solutions))
        print(f"\nTotal unique solutions found: {len(unique_solutions)}")
        for i, (n, x, y) in enumerate(unique_solutions, 1):
            print(f"\nSolution {i}:")
            print(f"  n = {n}")
            print(f"  x = {x}")
            print(f"  y = {y}")
            print(f"  Check: y = {-x + sqrt((x+6*n)**2 + (36*n**3-19)/x)}")
    else:
        print("\nNo solutions found with any approach.")
        print("\nSuggestions:")
        print("1. Try larger search ranges")
        print("2. The equation might require n,x to be very large")
        print("3. Check if the modular constraints are complete")
        print("4. The problem might have no integer solutions, or solutions are extremely rare")
